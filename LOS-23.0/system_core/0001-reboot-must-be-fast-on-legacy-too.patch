From ca2832fcafa97a3fc8af7cb54d90786eeb6acaf9 Mon Sep 17 00:00:00 2001
From: Yaroslav Zviezda <acroreiser@gmail.com>
Date: Mon, 20 Feb 2023 20:38:39 +0300
Subject: [PATCH 1/4] reboot must be fast on legacy too

Change-Id: I591d36fe86e68f391a8e11773bd91368c946b477
---
 init/reboot.cpp | 79 ++++++++++---------------------------------------
 1 file changed, 15 insertions(+), 64 deletions(-)

diff --git a/init/reboot.cpp b/init/reboot.cpp
index e07b93a6d..ece9a6b78 100644
--- a/init/reboot.cpp
+++ b/init/reboot.cpp
@@ -407,24 +407,6 @@ void RebootMonitorThread(unsigned int cmd, const std::string& reboot_target,
     }
 }
 
-static bool UmountDynamicPartitions(const std::vector<std::string>& dynamic_partitions) {
-    bool ret = true;
-    for (auto device : dynamic_partitions) {
-        // Cannot unmount /system
-        if (device == "/system") {
-            continue;
-        }
-        int r = umount2(device.c_str(), MNT_FORCE);
-        if (r == 0) {
-            LOG(INFO) << "Umounted success: " << device;
-        } else {
-            PLOG(WARNING) << "Cannot umount: " << device;
-            ret = false;
-        }
-    }
-    return ret;
-}
-
 /* Try umounting all emulated file systems R/W block device cfile systems.
  * This will just try umount and give it up if it fails.
  * For fs like ext4, this is ok as file system will be marked as unclean shutdown
@@ -444,52 +426,21 @@ static UmountStat TryUmountAndFsck(unsigned int cmd, bool run_fsck,
     if (run_fsck && !FindPartitionsToUmount(&block_devices, &emulated_devices, false)) {
         return UMOUNT_STAT_ERROR;
     }
-    auto sm = snapshot::SnapshotManager::New();
-    bool ota_update_in_progress = false;
-    if (sm->IsUserspaceSnapshotUpdateInProgress(dynamic_partitions)) {
-        LOG(INFO) << "OTA update in progress. Pause snapshot merge";
-        if (!sm->PauseSnapshotMerge()) {
-            LOG(ERROR) << "Snapshot-merge pause failed";
-        }
-        ota_update_in_progress = true;
-    }
-    UmountStat stat = UmountPartitions(timeout - t.duration());
-    if (stat != UMOUNT_STAT_SUCCESS) {
-        LOG(INFO) << "umount timeout, last resort, kill all and try";
-        if (DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
-        // Since umount timedout, we will try to kill all processes
-        // and do one more attempt to umount the partitions.
-        //
-        // However, if OTA update is in progress, we don't want
-        // to kill the snapuserd daemon as the daemon will
-        // be serving I/O requests. Killing the daemon will
-        // end up with I/O failures. If the update is in progress,
-        // we will just return the umount failure status immediately.
-        // This is ok, given the fact that killing the processes
-        // and doing an umount is just a last effort. We are
-        // still not doing fsck when all processes are killed.
-        //
-        if (ota_update_in_progress) {
-            bool umount_dynamic_partitions = UmountDynamicPartitions(dynamic_partitions);
-            LOG(INFO) << "Sending SIGTERM to all process";
-            // Send SIGTERM to all processes except init
-            WriteStringToFile("e", PROC_SYSRQ);
-            // Wait for processes to terminate
-            std::this_thread::sleep_for(1s);
-            // Try one more attempt to umount other partitions which failed
-            // earlier
-            if (!umount_dynamic_partitions) {
-                UmountDynamicPartitions(dynamic_partitions);
-            }
-            return stat;
-        }
-        KillAllProcesses();
-        // even if it succeeds, still it is timeout and do not run fsck with all processes killed
-        UmountStat st = UmountPartitions(0ms);
-        if ((st != UMOUNT_STAT_SUCCESS) && DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
-    }
+    LOG(INFO) << "Terminate all processes unconditionally...";
+    WriteStringToFile("e", PROC_SYSRQ);
+
+    LOG(INFO) << "Is anyone still alive? Kill them!";
+    KillAllProcesses();
+
+    LOG(INFO) << "Now remount all filesystems to RO";
+    WriteStringToFile("u", PROC_SYSRQ);
+
+    LOG(INFO) << "Unmount all partitions";
+    // even if it succeeds, still it is timeout and do not run fsck with all processes killed
+    UmountStat st = UmountPartitions(0ms);
+    if ((st != UMOUNT_STAT_SUCCESS) && DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
 
-    if (stat == UMOUNT_STAT_SUCCESS && run_fsck) {
+    if (st == UMOUNT_STAT_SUCCESS && run_fsck) {
         LOG(INFO) << "Pause reboot monitor thread before fsck";
         sem_post(reboot_semaphore);
 
@@ -502,7 +453,7 @@ static UmountStat TryUmountAndFsck(unsigned int cmd, bool run_fsck,
         LOG(INFO) << "Resume reboot monitor thread after fsck";
         sem_post(reboot_semaphore);
     }
-    return stat;
+    return st;
 }
 
 // zram is able to use backing device on top of a loopback device.
-- 
2.51.0

