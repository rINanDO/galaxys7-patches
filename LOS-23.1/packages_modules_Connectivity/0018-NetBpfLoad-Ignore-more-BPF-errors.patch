From a91c14459b7fafde22be49165da88d7a1601ff54 Mon Sep 17 00:00:00 2001
From: Dominggoes Isakh <drjisakh@gmail.com>
Date: Thu, 15 Jan 2026 22:51:23 +0100
Subject: [PATCH 18/18] NetBpfLoad: Ignore more BPF errors

Change-Id: I6d1a3c97c38497c16a896b7f16bce3c49d0fb32b
---
 bpf/loader/NetBpfLoad.cpp | 62 +++++++++++++++++++--------------------
 1 file changed, 30 insertions(+), 32 deletions(-)

diff --git a/bpf/loader/NetBpfLoad.cpp b/bpf/loader/NetBpfLoad.cpp
index e57626dbf7..8113d9500e 100644
--- a/bpf/loader/NetBpfLoad.cpp
+++ b/bpf/loader/NetBpfLoad.cpp
@@ -1660,46 +1660,44 @@ static int doLoad(char** argv, char * const envp[]) {
     // 25Q4 bumps the kernel requirement up to 5.10
     // see also: //system/netd/tests/kernel_test.cpp TestKernel510
     if (isAtLeast25Q4 && !isAtLeastKernelVersion(5, 10, 0)) {
-        ALOGE("Android 25Q4 requires kernel 5.10.");
-        return 1;
+        ALOGE("IGNORING: Android 25Q4 requires kernel 5.10.");
     }
 
     // Technically already required by U, but only enforce on V+
     // see also: //system/netd/tests/kernel_test.cpp TestKernel64Bit
     if (isAtLeastV && isKernel32Bit() && isAtLeastKernelVersion(5, 16, 0)) {
-        ALOGE("Android V+ platform with 32 bit kernel version >= 5.16.0 is unsupported");
-        if (!isTV()) return 1;
+        ALOGE("IGNORING: Android V+ platform with 32 bit kernel version >= 5.16.0 is unsupported");
+        // if (!isTV()) return 1;
     }
 
     if (isKernel32Bit() && isAtLeast25Q2) {
-        ALOGE("Android 25Q2 requires 64 bit kernel.");
-        return 1;
+        ALOGE("IGNORING: Android 25Q2 requires 64 bit kernel.");
+        // return 1;
     }
 
     // 6.6 is highest version supported by Android V, so this is effectively W+ (sdk=36+)
     if (isKernel32Bit() && isAtLeastKernelVersion(6, 7, 0)) {
-        ALOGE("Android platform with 32 bit kernel version >= 6.7.0 is unsupported");
-        return 1;
+        ALOGE("IGNORING: Android platform with 32 bit kernel version >= 6.7.0 is unsupported");
+        // return 1;
     }
 
     // Various known ABI layout issues, particularly wrt. bpf and ipsec/xfrm.
     if (isAtLeastV && isKernel32Bit() && isX86()) {
-        ALOGE("Android V requires X86 kernel to be 64-bit.");
-        if (!isTV()) return 1;
+        ALOGE("IGNORING: Android V requires X86 kernel to be 64-bit.");
+        // if (!isTV()) return 1;
     }
 
     if (isAtLeastV) {
         bool bad = false;
 
         if (!isLtsKernel()) {
-            ALOGW("Android V+ only supports LTS kernels.");
-            bad = true;
+            ALOGW("IGNORING:Android V+ only supports LTS kernels.");
+            // bad = true;
         }
 
 #define REQUIRE(maj, min, sub) \
         if (isKernelVersion(maj, min) && !isAtLeastKernelVersion(maj, min, sub)) { \
-            ALOGW("Android V+ requires %d.%d kernel to be %d.%d.%d+.", maj, min, maj, min, sub); \
-            bad = true; \
+            ALOGW("IGNORING: Android V+ requires %d.%d kernel to be %d.%d.%d+.", maj, min, maj, min, sub); \
         }
 
         REQUIRE(4, 19, 236)
@@ -1752,11 +1750,11 @@ static int doLoad(char** argv, char * const envp[]) {
             // might possibly be better for them to run with a newer kernel...
             ALOGW("[Arm KernelUpRev] 32-bit userspace unsupported on 6.2+ kernels.");
         } else if (isArm()) {
-            ALOGE("[Arm] 64-bit userspace required on 6.2+ kernels (%d).", first_api_level);
-            return 1;
+            ALOGE("IGNORING: [Arm] 64-bit userspace required on 6.2+ kernels (%d).", first_api_level);
+            // return 1;
         } else { // x86 since RiscV cannot be 32-bit
-            ALOGE("[x86] 64-bit userspace required on 6.2+ kernels.");
-            return 1;
+            ALOGE("IGNORING: [x86] 64-bit userspace required on 6.2+ kernels.");
+            // return 1;
         }
     }
 
@@ -1769,15 +1767,15 @@ static int doLoad(char** argv, char * const envp[]) {
     // 6.13+ (implying 26Q2+) requires 64-bit userspace.
     if (isUserspace32bit() && isAtLeastKernelVersion(6, 13, 0)) {
         // due to previous check only reachable on Arm && (<=T kernel uprev || TV || Wear)
-        ALOGE("64-bit userspace required on 6.13+ kernels.");
-        return 1;
+        ALOGE("IGNORING: 64-bit userspace required on 6.13+ kernels.");
+        // return 1;
     }
 
     if (isAtLeast25Q2) {
         FILE * f = fopen("/system/etc/init/netbpfload.rc", "re");
         if (!f) {
-            ALOGE("failure opening /system/etc/init/netbpfload.rc");
-            return 1;
+            ALOGE("IGNORING: failure opening /system/etc/init/netbpfload.rc");
+            // return 1;
         }
         int y = -1, q = -1, a = -1, b = -1, c = -1;
         int v = fscanf(f, "# %d %d %d %d %d #", &y, &q, &a, &b, &c);
@@ -1793,9 +1791,9 @@ static int doLoad(char** argv, char * const envp[]) {
 
     // Ensure we can determine the Android build type.
     if (!isEng() && !isUser() && !isUserdebug()) {
-        ALOGE("Failed to determine the build type: got %s, want 'eng', 'user', or 'userdebug'",
+        ALOGE("IGNORING: Failed to determine the build type: got %s, want 'eng', 'user', or 'userdebug'",
               getBuildType().c_str());
-        return 1;
+        // return 1;
     }
 
     if (runningAsRoot) {
@@ -1833,14 +1831,14 @@ static int doLoad(char** argv, char * const envp[]) {
         errno = 0;
         uint32_t progId = bpfGetNextProgId(0);  // expect 0 with errno == ENOENT
         if (progId || errno != ENOENT) {
-            ALOGE("bpfGetNextProgId(zero) returned %u (errno %d)", progId, errno);
-            return 1;
+            ALOGE("IGNORING: bpfGetNextProgId(zero) returned %u (errno %d)", progId, errno);
+            // return 1;
         }
         errno = 0;
         uint32_t mapId = bpfGetNextMapId(0);  // expect 0 with errno == ENOENT
         if (mapId || errno != ENOENT) {
-            ALOGE("bpfGetNextMapId(zero) returned %u (errno %d)", mapId, errno);
-            return 1;
+            ALOGE("IGNORING: bpfGetNextMapId(zero) returned %u (errno %d)", mapId, errno);
+            // return 1;
         }
     } else if (isAtLeastKernelVersion(4, 14, 0)) {  // implies S through U QPR2
         // bpfGetNext{Prog,Map}Id require 4.14+
@@ -1852,8 +1850,8 @@ static int doLoad(char** argv, char * const envp[]) {
             uint32_t next = bpfGetNextMapId(mapId);
             if (!next && errno == ENOENT) break;
             if (next <= mapId) {
-                ALOGE("bpfGetNextMapId(%u) returned %u errno %d", mapId, next, errno);
-                return 1;
+                ALOGE("IGNORING: bpfGetNextMapId(%u) returned %u errno %d", mapId, next, errno);
+                // return 1;
             }
             mapId = next;
         }
@@ -1865,8 +1863,8 @@ static int doLoad(char** argv, char * const envp[]) {
             // We should fail here on Xiaomi S 4.14.180 due to kernel uapi bug,
             // which causes bpfGetNextMapId to behave as bpfGetNextProgId,
             // and thus it should return 0 with errno == ENOENT.
-            ALOGE("bpfGetNextMapId(final %d) returned %d errno %d", mapId, next, errno);
-            return 1;
+            ALOGE("IGNORING: bpfGetNextMapId(final %d) returned %d errno %d", mapId, next, errno);
+            // return 1;
         }
     } else {  // implies S/T with 4.9 kernel
         // nothing we can do.
-- 
2.51.0

