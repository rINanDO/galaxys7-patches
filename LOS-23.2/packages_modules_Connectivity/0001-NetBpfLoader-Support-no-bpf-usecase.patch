From 7961424ab67fcdaa0e1c28791c25f5174d304bdd Mon Sep 17 00:00:00 2001
From: Dominggoes Isakh <drjisakh@gmail.com>
Date: Sat, 31 Jan 2026 16:13:36 +0100
Subject: [PATCH 1/6] NetBpfLoader: Support no bpf usecase

Change-Id: I048c7a9e118c9d2d60ccac46ba2311ffd635a95f
---
 bpf/loader/NetBpfLoad.cpp  | 59 +++++++++-----------------------------
 bpf/loader/netbpfload.rc   |  2 +-
 bpf/netd/NetdUpdatable.cpp |  6 +---
 3 files changed, 15 insertions(+), 52 deletions(-)

diff --git a/bpf/loader/NetBpfLoad.cpp b/bpf/loader/NetBpfLoad.cpp
index 238864798b..64d4249088 100644
--- a/bpf/loader/NetBpfLoad.cpp
+++ b/bpf/loader/NetBpfLoad.cpp
@@ -1594,12 +1594,10 @@ static int doLoad(char** argv, char * const envp[]) {
 
     if (!has_platform_bpfloader_rc && !has_platform_netbpfload_rc) {
         ALOGE("Unable to find platform's bpfloader & netbpfload init scripts.");
-        return 1;
     }
 
     if (has_platform_bpfloader_rc && has_platform_netbpfload_rc) {
         ALOGE("Platform has *both* bpfloader & netbpfload init scripts.");
-        return 2;
     }
 
     logTetheringApexVersion();
@@ -1608,27 +1606,23 @@ static int doLoad(char** argv, char * const envp[]) {
     // (this also guarantees 'kernelVer' isn't an invalid uninitialized 0)
     if (!isAtLeastKernelVersion(4, 9)) {
         ALOGE("Android S & T require kernel 4.9.");
-        return 3;
     }
 
     // U bumps the kernel requirement up to 4.14
     if (isAtLeastU && !isAtLeastKernelVersion(4, 14)) {
         ALOGE("Android U requires kernel 4.14.");
-        return 4;
     }
 
     // V bumps the kernel requirement up to 4.19
     // see also: //system/netd/tests/kernel_test.cpp TestKernel419
     if (isAtLeastV && !isAtLeastKernelVersion(4, 19)) {
         ALOGE("Android V requires kernel 4.19.");
-        return 5;
     }
 
     // 25Q2 bumps the kernel requirement up to 5.4
     // see also: //system/netd/tests/kernel_test.cpp TestKernel54
     if (isAtLeast25Q2 && !isAtLeastKernelVersion(5, 4)) {
         ALOGE("Android 25Q2 requires kernel 5.4.");
-        return 6;
     }
 
     // 25Q4 bumps the kernel requirement up to 5.10
@@ -1641,24 +1635,20 @@ static int doLoad(char** argv, char * const envp[]) {
     // see also: //system/netd/tests/kernel_test.cpp TestKernel64Bit
     if (isAtLeastV && isKernel32Bit() && isAtLeastKernelVersion(5, 16)) {
         ALOGE("Android V+ platform with 32 bit kernel version >= 5.16.0 is unsupported");
-        if (!isTV()) return 8;
     }
 
     if (isKernel32Bit() && isAtLeast25Q2) {
         ALOGE("Android 25Q2 requires 64 bit kernel.");
-        return 9;
     }
 
     // 6.6 is highest version supported by Android V, so this is effectively W+ (sdk=36+)
     if (isKernel32Bit() && isAtLeastKernelVersion(6, 7)) {
         ALOGE("Android platform with 32 bit kernel version >= 6.7.0 is unsupported");
-        return 10;
     }
 
     // Various known ABI layout issues, particularly wrt. bpf and ipsec/xfrm.
     if (isAtLeastV && isKernel32Bit() && isX86()) {
         ALOGE("Android V requires X86 kernel to be 64-bit.");
-        if (!isTV()) return 11;
     }
 
     if (isAtLeastV) {
@@ -1726,10 +1716,8 @@ static int doLoad(char** argv, char * const envp[]) {
             ALOGW("[Arm KernelUpRev] 32-bit userspace unsupported on 6.2+ kernels.");
         } else if (isArm()) {
             ALOGE("[Arm] 64-bit userspace required on 6.2+ kernels (%d).", first_api_level);
-            return 12;
         } else { // x86 since RiscV cannot be 32-bit
             ALOGE("[x86] 64-bit userspace required on 6.2+ kernels.");
-            return 13;
         }
     }
 
@@ -1743,7 +1731,6 @@ static int doLoad(char** argv, char * const envp[]) {
     if (isUserspace32bit() && isAtLeastKernelVersion(6, 13)) {
         // due to previous check only reachable on Arm && (<=T kernel uprev || TV || Wear)
         ALOGE("64-bit userspace required on 6.13+ kernels.");
-        return 14;
     }
 
     if (isAtLeast25Q2) {
@@ -1756,19 +1743,12 @@ static int doLoad(char** argv, char * const envp[]) {
         int v = fscanf(f, "# %d %d %d %d %d #", &y, &q, &a, &b, &c);
         ALOGI("detected %d of 5: %dQ%d api:%d.%d.%d", v, y, q, a, b, c);
         fclose(f);
-        if (v != 5) return 16;
-        if (y < 2025 || y > 2099) return 17;
-        if (q < 1 || q > 4) return 18;
-        if (a < 36) return 19;
-        if (b < 0 || b > 4) return 20;
-        if (c < 0) return 21;
     }
 
     // Ensure we can determine the Android build type.
     if (!isEng() && !isUser() && !isUserdebug()) {
         ALOGE("Failed to determine the build type: got %s, want 'eng', 'user', or 'userdebug'",
               getBuildType().c_str());
-        return 22;
     }
 
     if (runningAsRoot) {
@@ -1778,8 +1758,7 @@ static int doLoad(char** argv, char * const envp[]) {
         // but we need 0 (enabled)
         // (this writeFile is known to fail on at least 4.19, but always defaults to 0 on
         // pre-5.13, on 5.13+ it depends on CONFIG_BPF_UNPRIV_DEFAULT_OFF)
-        if (!writeFile("/proc/sys/kernel/unprivileged_bpf_disabled", "0\n") &&
-            isAtLeastKernelVersion(5, 13)) return 23;
+        writeFile("/proc/sys/kernel/unprivileged_bpf_disabled", "0\n");
     }
 
     if (isAtLeastU) {
@@ -1794,29 +1773,29 @@ static int doLoad(char** argv, char * const envp[]) {
         //  kernel does not have CONFIG_BPF_JIT=y)
         // BPF_JIT is required by R VINTF (which means 4.14/4.19/5.4 kernels),
         // but 4.14/4.19 were released with P & Q, and only 5.4 is new in R+.
-        if (!writeFile("/proc/sys/net/core/bpf_jit_enable", "1\n")) return 24;
+        writeFile("/proc/sys/net/core/bpf_jit_enable", "1\n");
 
         // Enable JIT kallsyms export for privileged users only
         // (Note: this (open) will fail with ENOENT 'No such file or directory' if
         //  kernel does not have CONFIG_HAVE_EBPF_JIT=y)
-        if (!writeFile("/proc/sys/net/core/bpf_jit_kallsyms", "1\n")) return 25;
+        writeFile("/proc/sys/net/core/bpf_jit_kallsyms", "1\n");
     }
 
     // Create all the pin subdirectories
     // (this must be done first to allow create_location and pin_subdir functionality,
     //  which could otherwise fail with ENOENT during object pinning or renaming,
     //  due to ordering issues)
-    if (!createDir("/sys/fs/bpf/tethering")) return 26;
+    createDir("/sys/fs/bpf/tethering");
     // This is technically T+ but S also needs it for the 'mainline_done' file.
-    if (!createDir("/sys/fs/bpf/netd_shared")) return 27;
+    createDir("/sys/fs/bpf/netd_shared");
 
     if (isAtLeastT) {
-        if (!createDir("/sys/fs/bpf/netd_readonly")) return 28;
-        if (!createDir("/sys/fs/bpf/net_shared")) return 29;
-        if (!createDir("/sys/fs/bpf/net_private")) return 30;
+        createDir("/sys/fs/bpf/netd_readonly");
+        createDir("/sys/fs/bpf/net_shared");
+        createDir("/sys/fs/bpf/net_private");
 
         // This one is primarily meant for triggering genfscon rules.
-        if (!createDir("/sys/fs/bpf/loader")) return 31;
+        createDir("/sys/fs/bpf/loader");
     }
 
     if (runningAsRoot) {  // implies U QPR3+ and kernel 4.14+
@@ -1825,13 +1804,11 @@ static int doLoad(char** argv, char * const envp[]) {
         uint32_t progId = bpfGetNextProgId(0);  // expect 0 with errno == ENOENT
         if (progId || errno != ENOENT) {
             ALOGE("bpfGetNextProgId(zero) returned %u (errno %d)", progId, errno);
-            return 32;
         }
         errno = 0;
         uint32_t mapId = bpfGetNextMapId(0);  // expect 0 with errno == ENOENT
         if (mapId || errno != ENOENT) {
             ALOGE("bpfGetNextMapId(zero) returned %u (errno %d)", mapId, errno);
-            return 33;
         }
     } else if (isAtLeastKernelVersion(4, 14)) {  // implies S through U QPR2
         // bpfGetNext{Prog,Map}Id require 4.14+
@@ -1844,7 +1821,6 @@ static int doLoad(char** argv, char * const envp[]) {
             if (!next && errno == ENOENT) break;
             if (next <= mapId) {
                 ALOGE("bpfGetNextMapId(%u) returned %u errno %d", mapId, next, errno);
-                return 34;
             }
             mapId = next;
         }
@@ -1857,12 +1833,10 @@ static int doLoad(char** argv, char * const envp[]) {
             // which causes bpfGetNextMapId to behave as bpfGetNextProgId,
             // and thus it should return 0 with errno == ENOENT.
             ALOGE("bpfGetNextMapId(final %d) returned %d errno %d", mapId, next, errno);
-            if (next || errno != ENOENT) return 35;
-            if (isAtLeastT || isAtLeastKernelVersion(4, 20)) return 36;
             // implies Android S with 4.14 or 4.19 kernel
             ALOGW("Detected kernel with invalid BPF UAPI - disabling mainline use of eBPF.");
             // leave a flag that we're 'done'
-            if (!createDir("/sys/fs/bpf/netd_shared/mainline_done")) return 37;
+            createDir("/sys/fs/bpf/netd_shared/mainline_done");
             return 0;
         }
     } else {  // implies S/T with 4.9 kernel
@@ -1875,9 +1849,6 @@ static int doLoad(char** argv, char * const envp[]) {
         ALOGE("If this triggers reliably, you're probably missing kernel options or patches.");
         ALOGE("If this triggers randomly, you might be hitting some memory allocation "
               "problems or startup script race.");
-        ALOGE("--- DO NOT EXPECT SYSTEM TO BOOT SUCCESSFULLY ---");
-        sleep(20);
-        return 38;
     }
 
     {
@@ -1888,33 +1859,29 @@ static int doLoad(char** argv, char * const envp[]) {
         int value = 123;
         if (writeToMapEntry(map, &one, &value, BPF_ANY)) {
             ALOGE("Critical kernel bug - failure to write into index 1 of 2 element bpf map array.");
-            if (isAtLeastT) return 39;
         }
 
         const char* const kernel_bugs_map_path = "/sys/fs/bpf/tethering/map_kernel_bugs";
         int ret = bpfFdPin(map, kernel_bugs_map_path);
         if (ret) {
             ALOGE("pin -> %d [%d:%s]", ret, errno, strerror(errno));
-            return 40;
         }
 
         ret = chmod(kernel_bugs_map_path, 0440);
         if (ret) {
             ALOGE("chmod %s 0440 -> %d [%d:%s]", kernel_bugs_map_path,
                   ret, errno, strerror(errno));
-            return 41;
         }
 
         ret = chown(kernel_bugs_map_path, AID_ROOT, AID_NETWORK_STACK);
         if (ret) {
             ALOGE("chown %s %d %d -> %d [%d:%s]", kernel_bugs_map_path, AID_ROOT,
                   AID_NETWORK_STACK, ret, errno, strerror(errno));
-            return 42;
         }
     }
 
     // leave a flag that we're done
-    if (!createDir("/sys/fs/bpf/netd_shared/mainline_done")) return 43;
+    createDir("/sys/fs/bpf/netd_shared/mainline_done");
 
     // platform bpfloader will only succeed when run as root
     if (!runningAsRoot) {
@@ -1939,8 +1906,8 @@ static int doLoad(char** argv, char * const envp[]) {
     // platform BpfLoader *needs* to run as root
     const char * args[] = { platformBpfLoader, NULL, };
     execve(args[0], (char**)args, envp);
-    ALOGE("FATAL: execve('%s'): %d[%s]", platformBpfLoader, errno, strerror(errno));
-    return 44;
+    ALOGE("ERROR: execve('%s'): %d[%s]", platformBpfLoader, errno, strerror(errno));
+    return 0;
 }
 
 }  // namespace bpf
diff --git a/bpf/loader/netbpfload.rc b/bpf/loader/netbpfload.rc
index 0430dfe48a..597f81fb03 100644
--- a/bpf/loader/netbpfload.rc
+++ b/bpf/loader/netbpfload.rc
@@ -12,5 +12,5 @@
 service bpfloader /system/bin/false
     user root
     oneshot
-    reboot_on_failure reboot,netbpfload-missing
+#    reboot_on_failure reboot,netbpfload-missing
     updatable
diff --git a/bpf/netd/NetdUpdatable.cpp b/bpf/netd/NetdUpdatable.cpp
index 3b15916398..b0fa1a2cbe 100644
--- a/bpf/netd/NetdUpdatable.cpp
+++ b/bpf/netd/NetdUpdatable.cpp
@@ -29,11 +29,7 @@ int libnetd_updatable_init(const char* cg2_path) {
     android::base::InitLogging(/*argv=*/nullptr);
     LOG(INFO) << __func__ << ": Initializing";
 
-    android::netdutils::Status ret = sBpfHandler.init(cg2_path);
-    if (!android::netdutils::isOk(ret)) {
-        LOG(ERROR) << __func__ << ": Failed: (" << ret.code() << ") " << ret.msg();
-        abort();
-    }
+    static_cast<void>(sBpfHandler.init(cg2_path));
     return 0;
 }
 
-- 
2.51.0

