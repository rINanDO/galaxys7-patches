From b470ab2cf949da40e4cf3dbf4824a0be475d1592 Mon Sep 17 00:00:00 2001
From: Yaroslav Zviezda <acroreiser@gmail.com>
Date: Tue, 2 Apr 2024 23:57:53 +0300
Subject: [PATCH 8/8] Revert "[BR03.2] Implement NetworkStack
 is-uid-networking-blocked shell command"

This reverts commit a75c5a64375630929178ce933d552cc6a1257db7.
---
 Android.bp                                    |   1 -
 .../android/server/NetworkStackService.java   | 231 ------------------
 2 files changed, 232 deletions(-)

diff --git a/Android.bp b/Android.bp
index aaae62e02..b3111959d 100644
--- a/Android.bp
+++ b/Android.bp
@@ -289,7 +289,6 @@ java_defaults {
         "modules-utils-build_system",
         "modules-utils-expresslog",
         "modules-utils-preconditions",
-        "modules-utils-shell-command-handler",
         "modules-utils-statemachine",
         "netd_aidl_interface-lateststable-java",
         "networkstack-client",
diff --git a/src/com/android/server/NetworkStackService.java b/src/com/android/server/NetworkStackService.java
index 533fbe17c..d69021b0f 100644
--- a/src/com/android/server/NetworkStackService.java
+++ b/src/com/android/server/NetworkStackService.java
@@ -23,13 +23,11 @@ import static android.net.util.RawPacketTracker.MAX_CAPTURE_TIME_MS;
 import static android.net.util.RawSocketUtils.sendRawPacketDownStream;
 
 import static com.android.net.module.util.DeviceConfigUtils.getResBooleanConfig;
-import static com.android.net.module.util.FeatureVersions.FEATURE_IS_UID_NETWORKING_BLOCKED;
 import static com.android.server.util.PermissionUtil.checkDumpPermission;
 
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
-import android.net.ConnectivityManager;
 import android.net.IIpMemoryStore;
 import android.net.IIpMemoryStoreCallbacks;
 import android.net.INetd;
@@ -54,7 +52,6 @@ import android.net.util.RawSocketUtils;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.Looper;
-import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.text.TextUtils;
 import android.util.ArraySet;
@@ -65,8 +62,6 @@ import androidx.annotation.VisibleForTesting;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.util.IndentingPrintWriter;
-import com.android.modules.utils.BasicShellCommandHandler;
-import com.android.net.module.util.DeviceConfigUtils;
 import com.android.net.module.util.HandlerUtils;
 import com.android.net.module.util.SharedLog;
 import com.android.networkstack.NetworkStackNotifier;
@@ -477,232 +472,6 @@ public class NetworkStackService extends Service {
                     R.bool.config_no_sim_card_uses_neighbor_mcc, false));
         }
 
-        @Override
-        public int handleShellCommand(@NonNull ParcelFileDescriptor in,
-                @NonNull ParcelFileDescriptor out, @NonNull ParcelFileDescriptor err,
-                @NonNull String[] args) {
-            return new ShellCmd().exec(this, in.getFileDescriptor(), out.getFileDescriptor(),
-                    err.getFileDescriptor(), args);
-        }
-
-        private String apfShellCommand(String iface, String cmd, @Nullable String optarg) {
-            synchronized (mIpClients) {
-                // HACK: An old IpClient serving the given interface name might not have been
-                // garbage collected. Since new IpClients are always appended to the list, iterate
-                // through it in reverse order to get the most up-to-date IpClient instance.
-                // Create a ListIterator at the end of the list.
-                final ListIterator it = mIpClients.listIterator(mIpClients.size());
-                while (it.hasPrevious()) {
-                    final IpClient ipClient = ((WeakReference<IpClient>) it.previous()).get();
-                    if (ipClient != null && ipClient.getInterfaceName().equals(iface)) {
-                        return ipClient.apfShellCommand(cmd, optarg);
-                    }
-                }
-            }
-            throw new IllegalArgumentException("No active IpClient found for interface " + iface);
-        }
-
-        private class ShellCmd extends BasicShellCommandHandler {
-            private static final long MAX_CAPTURE_CMD_WAITING_TIMEOUT_MS = 30_000L;
-
-            @Override
-            public int onCommand(String cmd) {
-                if (cmd == null) {
-                    return handleDefaultCommands(cmd);
-                }
-                final PrintWriter pw = getOutPrintWriter();
-                switch (cmd) {
-                    case "is-uid-networking-blocked":
-                        if (!DeviceConfigUtils.isFeatureSupported(mContext,
-                                FEATURE_IS_UID_NETWORKING_BLOCKED)) {
-                            throw new IllegalStateException("API is unsupported");
-                        }
-
-                        // Usage : cmd network_stack is-uid-networking-blocked <uid> <metered>
-                        // If no argument, get and display the usage help.
-                        if (getRemainingArgsCount() != 2) {
-                            onHelp();
-                            throw new IllegalArgumentException("Incorrect number of arguments");
-                        }
-                        final int uid;
-                        final boolean metered;
-                        uid = Integer.parseInt(getNextArg());
-                        metered = Boolean.parseBoolean(getNextArg());
-                        final ConnectivityManager cm =
-                                mContext.getSystemService(ConnectivityManager.class);
-                        pw.println(cm.isUidNetworkingBlocked(uid, metered /* isNetworkMetered */));
-                        return 0;
-                    case "send-raw-packet-downstream": {
-                        // Usage : cmd network_stack send-raw-packet-downstream
-                        //         <interface> <packet-in-hex>
-                        // If no argument, get and display the usage help.
-                        if (getRemainingArgsCount() != 2) {
-                            onHelp();
-                            throw new IllegalArgumentException("Incorrect number of arguments");
-                        }
-                        final String iface = getNextArg();
-                        final String packetInHex = getNextArg();
-                        try {
-                            sendRawPacketDownStream(mContext, iface, packetInHex);
-                        } catch (Exception e) {
-                            throw new RuntimeException(e);
-                        }
-                        return 0;
-                    }
-                    case "capture":
-                        // Usage: cmd network_stack capture <cmd>
-                        HandlerUtils.runWithScissorsForDump(
-                                sRawPacketTracker.getHandler(),
-                                () -> captureShellCommand(mContext, peekRemainingArgs()),
-                                MAX_CAPTURE_CMD_WAITING_TIMEOUT_MS
-                        );
-                        return 0;
-                    case "apf":
-                        // Usage: cmd network_stack apf <iface> <cmd>
-                        final String iface = getNextArg();
-                        if (iface == null) {
-                            throw new IllegalArgumentException("No <iface> specified");
-                        }
-
-                        final String subcmd = getNextArg();
-                        if (subcmd == null) {
-                            throw new IllegalArgumentException("No <cmd> specified");
-                        }
-
-                        final String optarg = getNextArg();
-                        if (getRemainingArgsCount() != 0) {
-                            throw new IllegalArgumentException("Too many arguments passed");
-                        }
-
-                        final String result = apfShellCommand(iface, subcmd, optarg);
-                        pw.println(result);
-                        return 0;
-
-                    default:
-                        return handleDefaultCommands(cmd);
-                }
-            }
-
-            @Override
-            public void onHelp() {
-                PrintWriter pw = getOutPrintWriter();
-                pw.println("NetworkStack service commands:");
-                pw.println("  help");
-                pw.println("    Print this help text.");
-                pw.println("  is-uid-networking-blocked <uid> <metered>");
-                pw.println("    Get whether the networking is blocked for given uid and metered.");
-                pw.println("    <uid>: The target uid.");
-                pw.println("    <metered>: [true|false], Whether the target network is metered.");
-                pw.println("  send-raw-packet-downstream <interface> <packet-in-hex>");
-                pw.println("    Send raw packet for testing purpose.");
-                pw.println("    <interface>: Target interface name, note that this is limited");
-                pw.println("      to tethering downstream for security considerations.");
-                pw.println("    <packet_in_hex>: A valid hexadecimal representation of ");
-                pw.println("      a packet starting from L2 header.");
-                pw.println("  capture <cmd>");
-                pw.println("    APF utility commands for multi-devices tests.");
-                pw.println("    start <interface>");
-                pw.println("      start capture packets in the received buffer.");
-                pw.println("      The capture is up to 300 sec, then it will stop.");
-                pw.println("      <interface>: Target interface name, note that this is limited");
-                pw.println("        to tethering downstream for security considerations.");
-                pw.println("    stop <interface>");
-                pw.println("      stop capture packets and clear the received buffer.");
-                pw.println("    matched-packet-counts <interface> <pkt-hex-string>");
-                pw.println("      the <pkt-hex-string> starts from ether header.");
-                pw.println("      Expect to do full packet match.");
-                pw.println("  apf <iface> <cmd>");
-                pw.println("    APF utility commands for integration tests.");
-                pw.println("    <iface>: the network interface the provided command operates on.");
-                pw.println("    <cmd>: [status]");
-                pw.println("      status");
-                pw.println("        returns whether the APF filter is \"running\" or \"paused\".");
-                pw.println("      pause");
-                pw.println("        pause APF filter generation.");
-                pw.println("      resume");
-                pw.println("        resume APF filter generation.");
-                pw.println("      install <program-hex-string>");
-                pw.println("        install the APF program contained in <program-hex-string>.");
-                pw.println("        The filter must be paused before installing a new program.");
-                pw.println("      capabilities");
-                pw.println("        return the reported APF capabilities.");
-                pw.println("        Format: <apfVersion>,<maxProgramSize>,<packetFormat>");
-                pw.println("      read");
-                pw.println("        reads and returns the current state of APF memory.");
-                pw.println("      dump-counters");
-                pw.println("        dump APF packet counters.");
-                pw.println("      config");
-                pw.println("        get APF config messages.");
-            }
-
-            private void captureShellCommand(
-                    @NonNull Context context,
-                    @NonNull String[] args
-            ) {
-                if (args.length < 2) {
-                    throw new IllegalArgumentException("Incorrect number of arguments");
-                }
-
-                final String cmd = args[0];
-                final String ifaceName = args[1];
-                try {
-                    RawSocketUtils.enforceTetheredInterface(context, ifaceName);
-                } catch (ExecutionException
-                         | InterruptedException
-                         | TimeoutException
-                         | SecurityException e) {
-                    throw new RuntimeException(e.getMessage());
-                }
-
-                final PrintWriter pw = getOutPrintWriter();
-                switch(cmd) {
-                    case "start":
-                        // Usage : cmd network_stack capture start <interface>
-                        if (args.length != 2) {
-                            throw new IllegalArgumentException("Incorrect number of arguments");
-                        }
-
-                        sRawPacketTracker.startCapture(ifaceName, MAX_CAPTURE_TIME_MS);
-                        pw.println("success");
-                        break;
-                    case "matched-packet-counts":
-                        // Usage : cmd network_stack capture matched-packet-counts
-                        //         <interface> <packet-in-hex>
-                        // for example, there is an usage to get matched arp reply packet count
-                        // in hex string format on the wlan0 interface
-                        // cmd network_stack capture matched-packet-counts wlan0 \
-                        // "00010203040501020304050608060001080006040002010203040506c0a80101" +
-                        // "000102030405c0a80102"
-                        if (args.length != 3) {
-                            throw new IllegalArgumentException("Incorrect number of arguments");
-                        }
-
-                        final String packetInHex = args[2];
-
-                        // limit the input hex string up to 3000 (1500 bytes)
-                        if (packetInHex.length() > 3000) {
-                            throw new IllegalArgumentException("Packet Hex String over the limit");
-                        }
-
-                        final int pktCnt =
-                                sRawPacketTracker.getMatchedPacketCount(ifaceName, packetInHex);
-                        pw.println(pktCnt);
-                        break;
-                    case "stop":
-                        // Usage : cmd network_stack capture stop <interface>
-                        if (args.length != 2) {
-                            throw new IllegalArgumentException("Incorrect number of arguments");
-                        }
-
-                        sRawPacketTracker.stopCapture(ifaceName);
-                        pw.println("success");
-                        break;
-                    default:
-                        throw new IllegalArgumentException("Invalid apf command: " + cmd);
-                }
-            }
-        }
-
         /**
          * Dump version information of the module and detected system version.
          */
-- 
2.51.0

