From d5a08fcc227b7165bf54acf1a5dade5eef800b71 Mon Sep 17 00:00:00 2001
From: Yaroslav Zviezda <acroreiser@gmail.com>
Date: Mon, 20 Feb 2023 20:38:39 +0300
Subject: [PATCH 1/5] reboot must be fast on legacy too

Change-Id: I591d36fe86e68f391a8e11773bd91368c946b477
---
 init/reboot.cpp | 82 ++++++++++---------------------------------------
 1 file changed, 17 insertions(+), 65 deletions(-)

diff --git a/init/reboot.cpp b/init/reboot.cpp
index 559282e5ee..9e9e93a87a 100644
--- a/init/reboot.cpp
+++ b/init/reboot.cpp
@@ -491,24 +491,6 @@ static void StartRebootMonitorThread(unsigned int cmd, const Timer& shutdown_tim
     reboot_monitor_thread.detach();
 }
 
-static bool UmountDynamicPartitions(const std::vector<std::string>& dynamic_partitions) {
-    bool ret = true;
-    for (auto device : dynamic_partitions) {
-        // Cannot unmount /system
-        if (device == "/system") {
-            continue;
-        }
-        int r = umount2(device.c_str(), MNT_FORCE);
-        if (r == 0) {
-            LOG(INFO) << "Umounted success: " << device;
-        } else {
-            PLOG(WARNING) << "Cannot umount: " << device;
-            ret = false;
-        }
-    }
-    return ret;
-}
-
 /* Try umounting all emulated file systems R/W block device cfile systems.
  * This will just try umount and give it up if it fails.
  * For fs like ext4, this is ok as file system will be marked as unclean shutdown
@@ -524,55 +506,25 @@ static UmountStat TryUmount(unsigned int cmd, std::chrono::milliseconds timeout)
     std::vector<MountEntry> emulated_devices;
     std::vector<std::string> dynamic_partitions;
 
-    bool ota_update_in_progress = false;
-    if (!IsMicrodroid()) {
-        auto sm = snapshot::SnapshotManager::New();
-        if (sm->IsUserspaceSnapshotUpdateInProgress(dynamic_partitions)) {
-            LOG(INFO) << "OTA update in progress. Pause snapshot merge";
-            if (!sm->PauseSnapshotMerge()) {
-                LOG(ERROR) << "Snapshot-merge pause failed";
-            }
-            ota_update_in_progress = true;
-        }
-    }
-    UmountStat stat = UmountPartitions(timeout - t.duration(), ota_update_in_progress);
-    if (stat != UMOUNT_STAT_SUCCESS) {
-        // Do not delete: Critical log for reboot_fs_integrity_test.
-        KLOG_INFO(LOG_TAG, "umount timeout, last resort, kill all and try");
-        if (DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
-        // Since umount timedout, we will try to kill all processes
-        // and do one more attempt to umount the partitions.
-        //
-        // However, if OTA update is in progress, we don't want
-        // to kill the snapuserd daemon as the daemon will
-        // be serving I/O requests. Killing the daemon will
-        // end up with I/O failures. If the update is in progress,
-        // we will just return the umount failure status immediately.
-        // This is ok, given the fact that killing the processes
-        // and doing an umount is just a last effort. We are
-        // still not doing fsck when all processes are killed.
-        //
-        if (ota_update_in_progress) {
-            bool umount_dynamic_partitions = UmountDynamicPartitions(dynamic_partitions);
-            LOG(INFO) << "Sending SIGTERM to all process";
-            // Send SIGTERM to all processes except init
-            KillAllProcesses(/* force */ false);
-            // Wait for processes to terminate
-            std::this_thread::sleep_for(1s);
-            // Try one more attempt to umount other partitions which failed
-            // earlier
-            if (!umount_dynamic_partitions) {
-                UmountDynamicPartitions(dynamic_partitions);
-            }
-            return stat;
-        }
-        KillAllProcesses(/* force */ true);
-        // even if it succeeds, still it is timeout and do not run fsck with all processes killed
-        UmountStat st = UmountPartitions(0ms, ota_update_in_progress);
-        if ((st != UMOUNT_STAT_SUCCESS) && DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
+    if (!FindPartitionsToUmount(&block_devices, &emulated_devices)) {
+        return UMOUNT_STAT_ERROR;
     }
+    
+    LOG(INFO) << "Terminate all processes unconditionally...";
+    WriteStringToFile("e", PROC_SYSRQ);
+
+    LOG(INFO) << "Is anyone still alive? Kill them!";
+    KillAllProcesses(true);
+
+    LOG(INFO) << "Now remount all filesystems to RO";
+    WriteStringToFile("u", PROC_SYSRQ);
 
-    return stat;
+    LOG(INFO) << "Unmount all partitions";
+    // even if it succeeds, still it is timeout and do not run fsck with all processes killed
+    UmountStat st = UmountPartitions(0ms, false);
+    if ((st != UMOUNT_STAT_SUCCESS) && DUMP_ON_UMOUNT_FAILURE) DumpUmountDebuggingInfo();
+ 
+    return st;
 }
 
 // zram is able to use backing device on top of a loopback device.
-- 
2.51.0

